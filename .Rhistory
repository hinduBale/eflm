## Grafico de burbujas (Residuos std, Hat, Cook)
car::influencePlot(fit, id = TRUE)
r <- rstandard(fit)
car::qqPlot(r, envelope = 0.95)
fit2 <- update(fit, subset = rownames(datos2)!="WY")
summary(fit2)
car::compareCoefs(fit, fit2)
fit3 <- update(fit, subset=!(rownames(datos2) %in% c("SD","NV","WY")))
summary(fit3)
fit3 <- update(fit, subset=!(rownames(datos2) %in% c("SD","NV","WY")))
summary(fit3)
car::compareCoefs(fit, fit2, fit3)
summary(fit4)
summary(fit3)
## Parte a)
fit<-eglm(consumo~tasa+licencia+ingreso,data = datos2)
fit4 <- update(fit, subset=!(rownames(datos2) %in% c("NY","SD","TX","NV","CT"))  )
fit<-glm(consumo~tasa+licencia+ingreso,data = datos2)
fit4 <- update(fit, subset=!(rownames(datos2) %in% c("NY","SD","TX","NV","CT"))  )
summary(fit4)
summary(fit3)
summary(fit2)
summary(fit3)
summary(fit3)
summary(fit2)
summary(fit3)
summary(fit2)
car::compareCoefs(fit, fit2, fit3, fit4)
c(AIC(fit),AIC(fit2),AIC(fit3),AIC(fit4))
Sys.time(1+1)
Sys.time()
system.time(1+!)
system.time(1+1)
system.time(1:1000)
use_test("subset")
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4, am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
# FIX
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
function(x, a, b) {
mode <- max(0, b * (a - 1))
p <- function(y) dgamma(y, shape=a, scale=b) - x
if(x < 0 || p(mode) < 0) stop()
if(a <= 1) {
left <- 0
} else {
left <- uniroot(p, c(0, mode))$root
}
right <- uniroot(p, c(mode, qgamma(0.999, shape=a, scale=b)))$root
interval <- c(left, right)pp <- sum(c(-1, 1) * pgamma(interval, shape=a, scale=b))
return(list(interval=interval, prob=pp))
}
a <- 2
b <- 1
f <- function(x) prob.cut(x, a, b)$prob - 0.95
o <- uniroot(f, c(1e-03, dgamma(b * (a - 1), shape=a, scale=b)))
curve(dgamma(x, shape=a, scale=b), xlim=c(0, 7))
oo <- prob.cut(o$root, a, b);
print(oo)
a <- 2
b <- 1
f <- function(x) prob.cut(x, a, b)$prob - 0.95
o <- uniroot(f, c(1e-03, dgamma(b * (a - 1), shape=a, scale=b)))
prob.cut <- function(x, a, b) {
mode <- max(0, b * (a - 1))
p <- function(y) dgamma(y, shape=a, scale=b) - x
if(x < 0 || p(mode) < 0) stop()
if(a <= 1) {
left <- 0
} else {
left <- uniroot(p, c(0, mode))$root
}
right <- uniroot(p, c(mode, qgamma(0.999, shape=a, scale=b)))$root
interval <- c(left, right)pp <- sum(c(-1, 1) * pgamma(interval, shape=a, scale=b))
return(list(interval=interval, prob=pp))
}
a <- 2
b <- 1
f <- function(x) prob.cut(x, a, b)$prob - 0.95
o <- uniroot(f, c(1e-03, dgamma(b * (a - 1), shape=a, scale=b)))
curve(dgamma(x, shape=a, scale=b), xlim=c(0, 7))
oo <- prob.cut(o$root, a, b);
print(oo)
return(list(interval=interval, prob=pp))
a <- 2
b <- 1
f <- function(x) prob.cut(x, a, b)$prob - 0.95
o <- uniroot(f, c(1e-03, dgamma(b * (a - 1), shape=a, scale=b)))
prob.cut <- function(x, a, b) {
mode <- max(0, b * (a - 1))
p <- function(y) dgamma(y, shape=a, scale=b) - x
if(x < 0 || p(mode) < 0) stop()
if(a <= 1) {
left <- 0
} else {
left <- uniroot(p, c(0, mode))$root
}
right <- uniroot(p, c(mode, qgamma(0.999, shape=a, scale=b)))$root
interval <- c(left, right)pp <- sum(c(-1, 1) * pgamma(interval, shape=a, scale=b))
return(list(interval=interval, prob=pp))
}
prob.cut <- function(x, a, b) {
mode <- max(0, b * (a - 1))
p <- function(y) dgamma(y, shape=a, scale=b) - x
if(x < 0 || p(mode) < 0) stop("bla bla")
if(a <= 1) {
left <- 0
} else {
left <- uniroot(p, c(0, mode))$root
}
right <- uniroot(p, c(mode, qgamma(0.999, shape=a, scale=b)))$root
interval <- c(left, right)
pp <- sum(c(-1, 1) * pgamma(interval, shape=a, scale=b))
return(list(interval=interval, prob=pp))
}
a <- 2
b <- 1
f <- function(x) prob.cut(x, a, b)$prob - 0.95
o <- uniroot(f, c(1e-03, dgamma(b * (a - 1), shape=a, scale=b)))
curve(dgamma(x, shape=a, scale=b), xlim=c(0, 7))
oo <- prob.cut(o$root, a, b);
print(oo)
B <- c(2, 47, 192, 256, 768, 896, 120, 896, 1184, 1024)
D <- c(0, 8, 28, 41, 63, 79, 97, 117, 135, 154)
N0 <- B[1]
n <- length(B)
Fu <- function(u) {
K <- u[1]
r <- u[2]
fu <- K * N0 / (N0 + (K - N0) * exp(-r * D))
return(sum((B - fu)**2))
}
dF <- function(u) {
K <- u[1]
r <- u[2]
fu <- K * N0 / (N0 + (K - N0) * exp(-r * D))
o1 <- fu * (1 - fu * exp(-r * D)) / K
o2 <- fu**2 * (K - N0) * D * exp(-r * D) / K / N0
dfu <- matrix(c(o1, o2), nrow=2, ncol=n, byrow=TRUE)
return(2 * dfu %*% (B - fu))
}
ddF <- function(u) {
H <- matrix(0, 2, 2)
h <- .Machine$double.eps**(1 / 3)
for(i in 1:2) {
for(j in 1:2) {
u2 <- u1 <- u
u2[j] <- u2[j] + h
u1[j] <- u1[j] - h
H[i,j] <- (dF(u2) - dF(u1))[i,1] / 2 / h
}
}
H <- 0.5 * H + 0.5 * t(H) # to guarantee symmetry...return(H)}
return(H)
}
dF(c(800,0.1))
# haciendo el grafico
dF(c(8250,0.125))
# haciendo el grafico
dF(c(825,0.125))
# haciendo el grafico
dF(c(800,0.1))
# haciendo el grafico
dF(c(800,0.125))
# haciendo el grafico
dF(c(820,0.125))
# haciendo el grafico
dF(c(825,0.125))
# haciendo el grafico
dF(c(830,0.1))
# haciendo el grafico
dF(c(830,0.15))
# haciendo el grafico
dF(c(830,0.145))
mv.newton <- function(f, df, x0, eps=1e-08, maxiter=1000, ...) {
if(!exists("ginv")) library(MASS)
x <- x0
t <- 0
repeat {
t <- t + 1
x.new <- x - as.numeric(ginv(df(x, ...)) %*% f(x, ...))
if(mean(abs(x.new - x)) < eps | t >= maxiter) {
if(t >= maxiter) warning("Maximum number of iterations reached!")
break
}
x <- x.new
}
out <- list(solution=x.new, value=f(x.new, ...), iter=t)
return(out)
}
o.nr <- mv.newton(dF, ddF, c(800, 0.1))
print(o.nr)
g <- function(t) o.nr$x[1] * N0 / (N0 + (o.nr$x[1] - N0) * exp(-o.nr$x[2] * t))
curve(g, col=2, add=TRUE)
o.nr <- mv.newton(dF, ddF, c(825, 0.125))
print(o.nr)
g <- function(t) o.nr$x[1] * N0 / (N0 + (o.nr$x[1] - N0) * exp(-o.nr$x[2] * t))
curve(g, col=2, add=TRUE)
o.nr
g <- function(t) o.nr$x[1] * N0 / (N0 + (o.nr$x[1] - N0) * exp(-o.nr$x[2] * t))
g
o.nr$solution
Fu(o.nr$solution)
B <- c(2, 47, 192, 256, 768, 896, 120, 896, 1184, 1024)
D <- c(0, 8, 28, 41, 63, 79, 97, 117, 135, 154)
N0 <- B[1]
n <- length(B)
Q <- function(u) {
K <- u[1]
r <- u[2]
fu <- K * N0 / (N0 + (K - N0) * exp(-r * D))
return(sum((B - fu)**2))
}
dF <- function(u) {
K <- u[1]
r <- u[2]
fu <- K * N0 / (N0 + (K - N0) * exp(-r * D))
o1 <- fu * (1 - fu * exp(-r * D)) / K
o2 <- fu**2 * (K - N0) * D * exp(-r * D) / K / N0
dfu <- matrix(c(o1, o2), nrow=2, ncol=n, byrow=TRUE)
return(2 * dfu %*% (B - fu))
}
ddF <- function(u) {
H <- matrix(0, 2, 2)
h <- .Machine$double.eps**(1 / 3)
for(i in 1:2) {
for(j in 1:2) {
u2 <- u1 <- u
u2[j] <- u2[j] + h
u1[j] <- u1[j] - h
H[i,j] <- (dF(u2) - dF(u1))[i,1] / 2 / h
}
}
H <- 0.5 * H + 0.5 * t(H) # to guarantee symmetry...return(H)}
return(H)
}
mv.newton <- function(f, df, x0, eps=1e-08, maxiter=1000, ...) {
if(!exists("ginv")) library(MASS)
x <- x0
t <- 0
repeat {
t <- t + 1
x.new <- x - as.numeric(ginv(df(x, ...)) %*% f(x, ...))
if(mean(abs(x.new - x)) < eps | t >= maxiter) {
if(t >= maxiter) warning("Maximum number of iterations reached!")
break
}
x <- x.new
}
out <- list(solution=x.new, value=f(x.new, ...), iter=t)
return(out)
}
o.nr <- mv.newton(dF, ddF, c(825, 0.125))
print(o.nr)
Q(o.nr$solution)
m1 <- glm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- glm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
formula = log(mpg) ~ log(wt)
data = mtcars
subset = (cyl == 4 & am == 1)
weights = NULL
family = gaussian()
load_all()
weights = NULL
subset
subset = (cyl == 4 & am == 1)
na.action = na.omit
start = NULL
etastart = NULL
mustart = NULL
offset = NULL
model = TRUE
x = FALSE
y = TRUE
intercept = TRUE
singularity.method = c("eigen", "Cholesky", "qr")
tol.solve = .Machine$double.eps
tol.values = 1e-7
tol.vectors = 1e-7
tol.estimation = 1e-8
maxit = 25
k = 2
bypass = TRUE
call <- match.call()
## family (taken from R source)
if(is.character(family)) {
family <- get(family, mode = "function", envir = parent.frame())
}
family
if(is.function(family)) {
family <- family()
}
if(is.null(family$family)) {
print(family)
stop("'family' not recognized")
}
target <- y
M <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data", "weights", "subset", "na.action", "etastart",
"mustart", "offset"), names(M), 0L)
M <- M[c(1L, m)]
M$drop.unused.levels <- TRUE
M[[1L]] <- quote(stats::model.frame)
M <- eval(M, parent.frame())
M <- eval(M)
mtcars[cyl == 4 & am == 1, ]
mtcars[mtcars$cyl == 4 & mtcars$am == 1, ]
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1
m1$model
m2 <- eglm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
subset(mtcars, cyl == 4
subset(mtcars, cyl == 4)
subset(mtcars, cyl == 4 & am == 1)
library(eflm)
m1 <- glm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- glm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- glm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m2 <- eglm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
mtcars[cyl == 4, ]
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
subset(mtcars, NULL)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
styler::style_dir("R")
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
subset(mtcars, mpg == 4)
subset(mtcars, cyl == 4)
subset(mtcars, cyl == 4 & am == 1)
subset(mtcars, cyl == 4 & am == 0)
library(eflm)
test()
myfun <- function(d, subset) {
d <- subset(d, subset)
return(d)
}
myfun(mtcars)
myfun(mtcars, subset = NULL)
myfun(mtcars, cyl == 4)
myfun <- function(d, subset) {
d <- d[subset, , drop = FALSE]
return(d)
}
myfun(mtcars, cyl == 4)
myfun <- function(d, subset) {
d <- d[subset, , drop = FALSE]
return(d)
}
myfun(mtcars, cyl == 4)
myfun <- function(d, subset) {
subset <- eval(substitute(subset), d)
d <- d[subset, , drop = FALSE]
return(d)
}
myfun(mtcars, cyl == 4)
myfun <- function(d, subset) {
subset <- eval(substitute(subset), d)
d <- d[subset, , drop = FALSE]
return(d)
}
myfun(mtcars, cyl == 4)
myfun(mtcars, cyl == 4 & am == 1)
myfun(mtcars, cyl == 4 & am == 1)
myfun(mtcars, cyl == 4 & am == 0)
myfun <- function(d, subset) {
subset <- eval(substitute(subset), d)
#d <- d[subset, , drop = FALSE]
return(d)
}
myfun(mtcars, cyl == 4 & am == 0)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
myfun <- function(d, subset) {
d <- subset(data, eval(substitute(subset), d))
return(d)
}
myfun(mtcars, cyl == 4 & am == 0)
myfun <- function(d, subset) {
d <- subset(data, eval(substitute(subset), d))
return(d)
}
myfun(mtcars, cyl == 4 & am == 0)
myfun <- function(d, subset) {
subset <- eval(substitute(subset), d)
d <- d[subset, , drop = FALSE]
return(d)
}
myfun(mtcars, cyl == 4 & am == 0)
library(eflm)
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = cyl == 4)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = "cyl == 4 & am == 1")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
subs
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
library(eflm)
library(eflm)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
source('~/github/eflm/R/elm.R')
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
data
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
