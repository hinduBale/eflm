eglm2(mpg ~ wt, data = mtcars)
library(eflm)
eglm2(mpg ~ wt, data = mtcars)
library(eflm)
eglm2(mpg ~ wt, data = mtcars)
library(eflm)
eglm2(mpg ~ wt, data = mtcars)
library(eflm)
library(eflm)
test_that("subset works and returns the same results for lm and elm", {
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
# Fixed with Ben Raymond suggestions, rOpenSci
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(
predict(m1, newdata = mtcars, type = "response"),
predict(m2, newdata = mtcars, type = "response")
)
})
test_that("subset works and returns the same results for glm and eglm", {
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
expect_equal(
predict(m1, newdata = mtcars, type = "response"),
predict(m2, newdata = mtcars, type = "response")
)
})
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
# prediction from a rank-deficient fit here !!
expect_warning(expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
))
expect_warning(predict(m1, newdata = mtcars, type = "link"))
expect_warning(expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
))
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
# prediction from a rank-deficient fit here !!
expect_warning(expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
))
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
# prediction from a rank-deficient fit here !!
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
# prediction from a rank-deficient fit here !!
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
predict(m1, newdata = mtcars, type = "link")
predict(m2, newdata = mtcars, type = "link")
# prediction from a rank-deficient fit here !!
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
expect_equal(
predict(m1, newdata = mtcars, type = "response"),
predict(m2, newdata = mtcars, type = "response")
)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, weights = 1, subset = (cyl == 4 & am == 1))
mtcars %>% filter(cyl == 4 & am == 1)
library(dplyr)
mtcars %>% filter(cyl == 4 & am == 1)
mtcars %>% filter(cyl == 4 & am == 1) %>% dim()
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, weights = rep(1, 8), subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, weights = rep(1, 11), subset = (cyl == 4 & am == 1))
dim(mtcars)
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, weights = rep(1, 32), subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, weights = rep(1, 32), subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
library(eflm)
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m1 <- lm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- elm(log(mpg) ~ log(wt), data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(
predict(m1, newdata = mtcars, type = "response"),
predict(m2, newdata = mtcars, type = "response")
)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, subset = (cyl == 4 & am == 1))
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
expect_warning(predict(m2, newdata = mtcars, type = "response"))
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars)
expect_equal(AIC(m1), AIC(m2))
aic_m1_m2 <- AIC(m1, m2)
AIC(m1)
AIC(m2)
expect_equal(AIC(m1), AIC(m2))
aic_m1_m2 <- AIC(m1, m2)
expect_s3_class(aic_m1_m2, 'data.frame')
expect_equal(aic_m1_m2$df[1], aic_m1_m2$df[2])
expect_equal(aic_m1_m2$AIC[1], aic_m1_m2$AIC[2])
m1 <- summary(glm(mpg ~ wt, family = gaussian, data = mtcars))
m2 <- summary(eglm(mpg ~ wt, family = gaussian, data = mtcars))
m2 <- summary(eglm(mpg ~ wt, family = gaussian, data = mtcars))
library(eflm)
library(eflm)
library(eflm)
source('~/github/eflm/R/summary-eglm.R')
source('~/github/eflm/R/summary-eglm.R')
library(eflm)
library(eflm)
library(eflm)
test_that("eglm + vcovCL return the same as glm + vcovCL", {
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
expect_equal(vcov_m1, vcov_m2)
vcov_m1 <- sandwich::vcovCL(m1, cluster = eval(m1$call$data)[,"cyl"])
vcov_m2 <- sandwich::vcovCL(m2, cluster = eval(m2$call$data)[,"cyl"])
expect_equal(vcov_m1, vcov_m2)
})
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
test_that("eglm + vcovCL return the same as glm + vcovCL", {
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
expect_equal(vcov_m1, vcov_m2)
vcov_m1 <- sandwich::vcovCL(m1, cluster = eval(m1$call$data)[,"cyl"])
vcov_m2 <- sandwich::vcovCL(m2, cluster = eval(m2$call$data)[,"cyl"])
expect_equal(vcov_m1, vcov_m2)
})
library(eflm)
library(eflm)
test_that("eglm + vcovBS return the same as glm + vcovBS", {
# vcovBS uses bootstrap so I need a seed to compare two results!
with_seed <- function(seed, code) {
code <- substitute(code)
set.seed(seed)
eval.parent(code)
}
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
vcov_m1 <- with_seed(1813, sandwich::vcovBS(m1, cluster = NULL))
vcov_m2 <- with_seed(1813, sandwich::vcovBS(m2, cluster = NULL))
expect_equal(vcov_m1, vcov_m2)
vcov_m1 <- with_seed(1813, sandwich::vcovBS(m1, cluster = eval(m1$call$data)[,"cyl"]))
vcov_m2 <- with_seed(1813, sandwich::vcovBS(m2, cluster = eval(m2$call$data)[,"cyl"]))
expect_equal(vcov_m1, vcov_m2)
})
test_that("eglm + vcovCL return the same as glm + vcovCL", {
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
expect_equal(vcov_m1, vcov_m2)
vcov_m1 <- sandwich::vcovCL(m1, cluster = eval(m1$call$data)[,"cyl"])
vcov_m2 <- sandwich::vcovCL(m2, cluster = eval(m2$call$data)[,"cyl"])
expect_equal(vcov_m1, vcov_m2)
})
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
fm1 <- family(m1)
fm2 <- family(m2)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$link, fm2$link)
expect_equal(fitted(m1), fitted(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
library(eflm)
stats:::vcov.glm()
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
fm1 <- family(m1)
fm2 <- family(m2)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$link, fm2$link)
expect_equal(fitted(m1), fitted(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
fm1 <- family(m1)
fm2 <- family(m2)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$link, fm2$link)
expect_equal(fitted(m1), fitted(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
expect_equal(deviance(m1), deviance(m2))
expect_equal(nobs(m1), nobs(m2))
expect_equal(model.matrix(m1), model.matrix(m2))
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
fm1 <- family(m1)
fm2 <- family(m2)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$link, fm2$link)
expect_equal(fitted(m1), fitted(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
expect_equal(deviance(m1), deviance(m2))
expect_equal(nobs(m1), nobs(m2))
expect_equal(model.matrix(m1), model.matrix(m2))
library(eflm)
library(eflm)
# gaussian, gaussian() and "gaussian" are converted to gaussian()
m1 <- eglm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
m3 <- eglm(mpg ~ wt, family = "gaussian", data = mtcars)
expect_s3_class(m1, "eglm")
check()
check()
check()
styler::style_pkg()
styler::style_dir("R")
check()
library(eflm)
check()
check()
check()
check()
library(eflm)
check()
library(eflm)
check()
check()
check()
check()
check()
library(eflm)
