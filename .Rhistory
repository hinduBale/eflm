m2$qr$qraux
m1$qr$pivot
m2$qr$pivot
expect_equal(m1$qr$qr, m2$qr$qr)
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars, singularity.method = "qr")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
test_that("eglm (gaussian) + qr singularity.method == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars, singularity.method = "qr")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
})
test_that("eglm (gaussian) + cholesky singularity.method == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars, singularity.method = "Cholesky")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
expect_equal(
predict(m1, newdata = mtcars, type = "response"),
predict(m2, newdata = mtcars, type = "response")
)
})
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
expect_equal(fitted(m1), fitted(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
expect_equal(deviance(m1), deviance(m2))
expect_equal(nobs(m1), nobs(m2))
expect_equal(model.matrix(m1), model.matrix(m2))
class(m1)
class(m2)
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
m2
m1
class(m2)
class(m2) = "eglm"
nobs(m2)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
m1 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
nobs(m1)
class(m1)
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
family(m1)
family(m2)
expect_equal(family(m1), family(m2))
fm1 <- family(m1)
fm2 <- family(m2)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$link, fm2$link)
fm1$linkfun()
fm1$linkfun
fm1$aic
fm1$aic()
library(eflm)
test()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
check()
test()
library(eflm)
test()
check()
library(eflm)
library(eflm)
test()
m1 <- lm(mpg ~ wt + am, data = mtcars)
m2 <- elm(mpg ~ wt + am, data = mtcars)
resid(m1)
residuals(m1)
residuals(m2)
residuals(m2)
library(eflm)
test(0)
test()
check()
library(eflm)
test()
check()
library(eflm)
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
m1 <- eglm(mpg ~ I(wt^2), mtcars)
class(m1)
library(eflm)
m1 <- eglm(mpg ~ I(wt^2), mtcars)
class(m1)
check()
check()
library(eflm)
check()
use_r("eflm-package")
check()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
use_test("formulas")
m1 <- glm(mpg ~ I(wt^2) + log(cyl), family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ I(wt^2) + log(cyl), family = gaussian(), data = mtcars)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$qr$tol, m2$qr$tol)
library(testthat)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$qr$tol, m2$qr$tol)
expect_equal(m1$qr$qr, m2$qr$qr)
expect_equal(m1$qr$rank, m2$qr$rank)
expect_equal(m1$qr$qraux, m2$qr$qraux)
expect_equal(m1$qr$pivot, m2$qr$pivot)
expect_equal(m1$qr$pivot, m2$qr$pivot)
expect_equal(m1$qr$qraux, m2$qr$qraux)
expect_equal(m1$qr$rank, m2$qr$rank)
expect_equal(m1$qr$qr, m2$qr$qr)
use_readme_rmd()
ch1_application1_2 <- readRDS("~/github/eflm/dev/ch1_application1_2.rds")
codemetar::give_opinions()
1
codemetar::give_opinions()
codemetar::give_opinions()
codemetar::give_opinions()
codemetar::give_opinions()
library(eflm)
codemetar::give_opinions()
pkgdown::build_site()
pkgdown::build_site()
library(readxl)
tidy_benchmarks <- read_excel("dev/tidy benchmarks.xlsx")
View(tidy_benchmarks)
library(dplyr)
tidy_benchmarks %>% group_by(function) %>% summarise(Median = mean(Median))
tidy_benchmarks %>% group_by(Function) %>% summarise(Median = mean(Median))
46.2 / 11.7
remotes::install_github("ropenscilabs/autotest")
remotes::install_github("ropenscilabs/autotest")
install.packages("callr")
install.packages("callr")
edit_r_profile
usethis::edit_r_environ()
usethis::edit_r_profile()
remotes::install_github("ropenscilabs/autotest")
pkgdown::build_site()
pkgdown::build_site()
laod_all()
load_all()
m1 <- glm(mpg ~ I(wt^2), mtcars)
m1 <- glm(mpg ~ I(wt^2), data = mtcars)
m2 <- eglm(mpg ~ I(wt^2), data = mtcars)
summary(m1)
summary(m2)
m2 <- eglm(mpg ~ log(wt), data = mtcars)
m1 <- glm(mpg ~log(wt), data = mtcars)
m2 <- eglm(mpg ~ log(wt), data = mtcars)
summary(m1)
summary(m2)
library(eflm)
Y <- c(rep(0,35),1,2,0,6,8,16,43)
beta <- 42:1
cst <- lchoose(42, beta)
tau <- (beta^2)/2
fit <- glm(formula = Y ~ offset(cst) + beta + tau, family = poisson)
fit <- eglm(formula = Y ~ offset(cst) + beta + tau, family = poisson())
eglm(formula = Y ~ offset(cst) + beta + tau, family = poisson())
example(glm)
fm1 <- glm(lot1 ~ log(u), data = clotting, family = Gamma)
fm2 <- eglm(lot1 ~ log(u), data = clotting, family = Gamma())
hasDisp <- 1 # have dispersion (here, but not e.g., for binomial, poisson)
for(fm in list(fm1, fm2)) {
print(ll <- logLik(fm))
p <- attr(ll, "df")
A0 <- AIC(fm)
A1 <- -2*c(ll) + 2*p
aic.v <- fm$family$aic(y  = fm$y, mu = fitted(fm),
wt = weights(fm), dev= deviance(fm))
stopifnot(
p == (p. <- length(coef(fm))) + hasDisp,
all.equal(-2*c(ll) + 2*hasDisp, aic.v) # <fam>$aic() = -2 * loglik + 2s
)
A2 <- aic.v + 2 * p.
stopifnot(exprs = {
all.equal(A0, A1)
all.equal(A1, A2)
all.equal(A1, fm$aic)
})
}
fm1 <- glm(lot2 ~ log(u), data = clotting, family = Gamma())
fm2 <- eglm(lot2 ~ log(u), data = clotting, family = Gamma)
fm1 <- glm(lot2 ~ log(u), data = clotting, family = Gamma)
fm2 <- eglm(lot2 ~ log(u), data = clotting, family = Gamma())
hasDisp <- 1 # have dispersion (here, but not e.g., for binomial, poisson)
for(fm in list(fm1, fm2)) {
print(ll <- logLik(fm))
p <- attr(ll, "df")
A0 <- AIC(fm)
A1 <- -2*c(ll) + 2*p
aic.v <- fm$family$aic(y = fm$y, mu = fitted(fm),
wt = weights(fm), dev = deviance(fm))
stopifnot(
p == (p. <- length(coef(fm))) + hasDisp,
all.equal(-2*c(ll) + 2*hasDisp, aic.v) # <fam>$aic() = -2 * loglik + 2s
)
A2 <- aic.v + 2 * p.
stopifnot(exprs = {
all.equal(A0, A1)
all.equal(A1, A2)
all.equal(A1, fm$aic)
})
}
fm1 <- glm(lot1 ~ log(u), data = clotting, family = Gamma)
fm2 <- eglm(lot1 ~ log(u), data = clotting, family = Gamma())
hasDisp <- 1 # have dispersion (here, but not e.g., for binomial, poisson)
test_AICs <- function(L = list(fm1, fm2)) {
for(fm in L) {
print(ll <- logLik(fm))
p <- attr(ll, "df")
A0 <- AIC(fm)
A1 <- -2*c(ll) + 2*p
aic.v <- fm$family$aic(
y  = fm$y, mu = fitted(fm),
wt = weights(fm), dev= deviance(fm)
)
stopifnot(
p == (p. <- length(coef(fm))) + hasDisp,
all.equal(-2*c(ll) + 2*hasDisp, aic.v) # <fam>$aic() = -2 * loglik + 2s
)
A2 <- aic.v + 2 * p.
stopifnot(
exprs = {
all.equal(A0, A1)
all.equal(A1, A2)
all.equal(A1, fm$aic)
}
)
}
}
test_AICs()
bookdown::serve_book()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(eflm)
model3 <- "lot2 ~ log(u) + log(u^2)"
glm(lot2 ~ log(u) + log(u^2), data = clotting, family = Gamma)
clotting <- data.frame(
u    = c(5,10,15,20,30,40,60,80,100),
lot1 = c(118,58,42,35,27,25,21,19,18),
lot2 = c(69,35,26,21,18,16,13,12,12)
)
glm(lot2 ~ log(u) + log(u^2), data = clotting, family = Gamma)
model3 <- "lot2 ~ log(u) + log(u^2)"
glm(model3, data = clotting, family = Gamma)
eglm(model3, data = clotting, family = Gamma)
eglm(model3, data = clotting, family = Gamma())
help(anorexia)
??anorexia
data(anorexia, package = "MASS")
model1 <- "Postwt ~ Prewt + Treat + offset(Prewt)"
summary(glm(model1, family = gaussian, data = anorexia))
anorexia$Prewt
offset(anorexia$Prewt)
data(anorexia, package = "MASS")
model1 <- "Postwt ~ Prewt + Treat + offset(Prewt)"
summary(glm(model1, family = gaussian, data = anorexia))
data(anorexia, package = "MASS")
model1 <- "Postwt ~ Prewt + Treat + offset(Prewt)"
summary(glm(model1, family = gaussian, data = anorexia))
aaa = glm(model1, family = gaussian, data = anorexia)
predict(aaa)
anorexia[1,]
49.7711 + (-0.5655 * 80.7) + (-4.0971)
49.7711 + (-0.5655 * 80.7) + (-4.0971) + 80.7
broom::augment(aaa)
anorexia[2,]
49.7711 + (-0.5655 * 89.4) + (-4.0971) + 80.1
49.7711 + (-0.5655 * 89.4) + (-4.0971) + 89.4
pkgdown::build_site()
summary(eglm(model1, family = gaussian, data = anorexia))
summary(eglm(model1, family = gaussian(), data = anorexia))
pkgdown::build_site()
use_vignette("benchmarks")
pkgdown::build_site()
pkgdown::build_site()
library(usethis)
install.packages("usethis")
install.packages("usethis")
library(usethis)
session_info()
library(usethis)
edit_r_profile()
create_project("~/github/clase1")
datos1 <- data.frame(state.x77)
library(eflm)
## Primer ajuste
fit0 <- glm(Life.Exp~Murder, family = gaussian,  data=datos1)
## Devianza
fit0$deviance
fit0 <- eglm(Life.Exp~Murder, family = gaussian,  data=datos1)
fit0$deviance
summary(fit0)$dispersion
DE <- fit0$deviance /summary(fit0)$dispersion
DE > qchisq(0.95, df=nrow(datos)-2, lower.tail = TRUE)
DE > qchisq(0.95, df=nrow(datos1)-2, lower.tail = TRUE)
summary(fit0)
aux <- lm(Life.Exp~Murder, data = datos)
summary(aux)
aux <- lm(Life.Exp~Murder, data = datos1)
summary(aux)
fit1 <- glm(Life.Exp~Murder+Income, family = gaussian,  data=datos1)
summary(fit1)
summary(aux)
summary(aux)$dispersion
## Devianza
fit1$deviance
## Parametro de dispersion
summary(fit1)$dispersion
## Devianza escalada
DE <- fit1$deviance /summary(fit1)$dispersion
## No se rechaza la hipotesis nula
DE > qchisq(0.95, df=nrow(datos1)-3, lower.tail = TRUE)
pchisq(DE, df = nrow(datos)-3, lower.tail = FALSE)
## Valor-p
pchisq(DE, df = nrow(datos1)-3, lower.tail = FALSE)
DE0 <- fit0$deviance /summary(fit0)$dispersion
DE1 <- fit1$deviance /summary(fit1)$dispersion
(DE0-DE1)>qchisq(0.95, df=1, lower.tail = TRUE)
fit0$deviance
fit1$deviance
(DE0-DE1)>qchisq(0.95, df=1, lower.tail = TRUE)
pchisq((DE0-DE1), df = 1, lower.tail = FALSE)
datos2 <- readRDS(file.choose())
fit<-eglm(consumo~tasa+licencia+ingreso,data = datos2)
summary(fit)
## Parte b)
## Se pueden obtener todos los graficos con esta funcion
car::residualPlots(fit, type = "rstandard", id = TRUE)
fit<-glm(consumo~tasa+licencia+ingreso,data = datos2)
summary(fit)
car::residualPlots(fit, type = "rstandard", id = TRUE)
## Parte c)
car::residualPlots(fit, type = "deviance", id = TRUE)
d_cook <- stats::cooks.distance(fit)
h <- stats::hatvalues(fit)
## Graficos
car::influenceIndexPlot(fit, vars = "Cook", id = TRUE)
car::influenceIndexPlot(fit, vars = "hat", id = TRUE)
## Criterio: Di>4/(n-p-1)
d_cook[d_cook>4/(nrow(datos2)-5)]
## Criterio: Di>4/(n-p-1)
d_cook[d_cook>4/(nrow(datos2)-5)]
## Criterio: hi>2*p/n
h[h>2*4/nrow(datos2)]
## Criterio: Di>4/(n-p-1)
d_cook[d_cook>4/(nrow(datos2)-5)]
## Criterio: hi>2*p/n
h[h>2*4/nrow(datos2)]
## Grafico de burbujas (Residuos std, Hat, Cook)
car::influencePlot(fit, id = TRUE)
r <- rstandard(fit)
car::qqPlot(r, envelope = 0.95)
fit2 <- update(fit, subset = rownames(datos2)!="WY")
summary(fit2)
car::compareCoefs(fit, fit2)
fit3 <- update(fit, subset=!(rownames(datos2) %in% c("SD","NV","WY")))
summary(fit3)
fit3 <- update(fit, subset=!(rownames(datos2) %in% c("SD","NV","WY")))
summary(fit3)
car::compareCoefs(fit, fit2, fit3)
summary(fit4)
summary(fit3)
## Parte a)
fit<-eglm(consumo~tasa+licencia+ingreso,data = datos2)
fit4 <- update(fit, subset=!(rownames(datos2) %in% c("NY","SD","TX","NV","CT"))  )
fit<-glm(consumo~tasa+licencia+ingreso,data = datos2)
fit4 <- update(fit, subset=!(rownames(datos2) %in% c("NY","SD","TX","NV","CT"))  )
summary(fit4)
summary(fit3)
summary(fit2)
summary(fit3)
summary(fit3)
summary(fit2)
summary(fit3)
summary(fit2)
car::compareCoefs(fit, fit2, fit3, fit4)
c(AIC(fit),AIC(fit2),AIC(fit3),AIC(fit4))
Sys.time(1+1)
Sys.time()
system.time(1+!)
system.time(1+1)
system.time(1:1000)
