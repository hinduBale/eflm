stt <- paste(sort(strsplit(tt, ":")[[1L]]), collapse = ":")
usex <- match(asgn, match(stt, sTerms), 0L) > 0L
X <- x[, usex | ousex, drop = FALSE]
z <- boostedglm:::fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[tt] <- z$rank
dev[tt] <- z$deviance
if (test == "Rao") {
zz <- fglm.wfit(r, X, , w, offset = offset)
score[tt] <- zz$null.deviance - zz$deviance
}
}
for (tt in scope) {
stt <- paste(sort(strsplit(tt, ":")[[1L]]), collapse = ":")
usex <- match(asgn, match(stt, sTerms), 0L) > 0L
X <- x[, usex | ousex, drop = FALSE]
z <- boostedglm:::fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[tt] <- z$rank
dev[tt] <- z$deviance
if (test == "Rao") {
zz <- boostedglm:::fglm.wfit(r, X, , w, offset = offset)
score[tt] <- zz$null.deviance - zz$deviance
}
}
if (scale == 0) {
dispersion <- summary(object, dispersion = NULL)$dispersion
} else {
dispersion <- scale
}
dispersion
if (scale == 0) {
dispersion <- summary(object, dispersion = NULL)$dispersion
} else {
dispersion <- scale
}
scale
scale = 0
if (scale == 0) {
dispersion <- summary(object, dispersion = NULL)$dispersion
} else {
dispersion <- scale
}
dispersion
summary(object, dispersion = NULL)$dispersion
scale
foo = summary(object, dispersion = NULL)
library(boostedglm)
m1 <- glm(am ~ wt + mpg, data = mtcars, family = poisson())
add_m1 <- add1(m1, ~ I(mpg^2) + .^2, test = "Rao")
m2 <- fglm(am ~ wt + mpg, data = mtcars, family = poisson())
add_m2 <- add1(m2, ~ I(mpg^2) + .^2, test = "Rao")
object = m2
scope
scope = ~ I(mpg^2) + .^2
scale = 0
test = "Rao"
x = NULL
k = 2
weights = NULL
oTerms <- attr(object$terms, "term.labels")
int <- attr(object$terms, "intercept")
ns <- length(scope)
dfs <- dev <- score <- numeric(ns + 1)
names(dfs) <- names(dev) <- names(score) <- c("<none>", scope)
add.rhs <- paste(scope, collapse = "+")
add.rhs <- eval(parse(text = paste("~ . +", add.rhs), keep.source = FALSE))
new.form <- update.formula(object, add.rhs)
Terms <- terms(new.form)
y <- object$y
if (is.null(x)) {
fc <- object$call
fc$formula <- Terms
fob <- list(call = fc, terms = Terms)
class(fob) <- oldClass(object)
m <- model.frame(fob)
offset <- model.offset(m)
wt <- weights
x <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
oldn <- length(y)
y <- model.response(m)
if (!is.factor(y)) {
storage.mode(y) <- "double"
}
if (NCOL(y) == 2) {
n <- y[, 1] + y[, 2]
y <- ifelse(n == 0, 0, y[, 1] / n)
if (is.null(wt)) {
wt <- rep.int(1, length(y))
}
wt <- wt * n
}
newn <- length(y)
if (newn < oldn) {
warning(sprintf(
ngettext(
newn, "using the %d/%d row from a combined fit",
"using the %d/%d rows from a combined fit"
),
newn, oldn
), domain = NA)
}
} else {
wt <- object$prior.weights
offset <- object$offset
}
n <- nrow(x)
if (is.null(wt)) {
wt <- rep.int(1, n)
}
Terms <- attr(Terms, "term.labels")
asgn <- attr(x, "assign")
ousex <- match(asgn, match(oTerms, Terms), 0L) > 0L
if (int) {
ousex[1L] <- TRUE
}
X <- x[, ousex, drop = FALSE]
z <- fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[1L] <- z$rank
dev[1L] <- z$deviance
r <- z$residuals
w <- z$weights
sTerms <- sapply(strsplit(Terms, ":", fixed = TRUE), function(x) {
paste(sort(x),
collapse = ":"
)
})
for (tt in scope) {
stt <- paste(sort(strsplit(tt, ":")[[1L]]), collapse = ":")
usex <- match(asgn, match(stt, sTerms), 0L) > 0L
X <- x[, usex | ousex, drop = FALSE]
z <- fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[tt] <- z$rank
dev[tt] <- z$deviance
if (test == "Rao") {
zz <- fglm.wfit(r, X, , w, offset = offset)
score[tt] <- zz$null.deviance - zz$deviance
}
}
if (!is.character(scope)) {
scope <- add.scope(object, update.formula(object, scope))
}
oTerms <- attr(object$terms, "term.labels")
int <- attr(object$terms, "intercept")
ns <- length(scope)
dfs <- dev <- score <- numeric(ns + 1)
names(dfs) <- names(dev) <- names(score) <- c("<none>", scope)
add.rhs <- paste(scope, collapse = "+")
add.rhs <- eval(parse(text = paste("~ . +", add.rhs), keep.source = FALSE))
new.form <- update.formula(object, add.rhs)
Terms <- terms(new.form)
y <- object$y
if (is.null(x)) {
fc <- object$call
fc$formula <- Terms
fob <- list(call = fc, terms = Terms)
class(fob) <- oldClass(object)
m <- model.frame(fob)
offset <- model.offset(m)
wt <- weights
x <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
oldn <- length(y)
y <- model.response(m)
if (!is.factor(y)) {
storage.mode(y) <- "double"
}
if (NCOL(y) == 2) {
n <- y[, 1] + y[, 2]
y <- ifelse(n == 0, 0, y[, 1] / n)
if (is.null(wt)) {
wt <- rep.int(1, length(y))
}
wt <- wt * n
}
newn <- length(y)
if (newn < oldn) {
warning(sprintf(
ngettext(
newn, "using the %d/%d row from a combined fit",
"using the %d/%d rows from a combined fit"
),
newn, oldn
), domain = NA)
}
} else {
wt <- object$prior.weights
offset <- object$offset
}
n <- nrow(x)
if (is.null(wt)) {
wt <- rep.int(1, n)
}
Terms <- attr(Terms, "term.labels")
asgn <- attr(x, "assign")
ousex <- match(asgn, match(oTerms, Terms), 0L) > 0L
if (int) {
ousex[1L] <- TRUE
}
X <- x[, ousex, drop = FALSE]
z <- fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[1L] <- z$rank
dev[1L] <- z$deviance
r <- z$residuals
w <- z$weights
sTerms <- sapply(strsplit(Terms, ":", fixed = TRUE), function(x) {
paste(sort(x),
collapse = ":"
)
})
for (tt in scope) {
stt <- paste(sort(strsplit(tt, ":")[[1L]]), collapse = ":")
usex <- match(asgn, match(stt, sTerms), 0L) > 0L
X <- x[, usex | ousex, drop = FALSE]
z <- fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[tt] <- z$rank
dev[tt] <- z$deviance
if (test == "Rao") {
zz <- fglm.wfit(r, X, , w, offset = offset)
score[tt] <- zz$null.deviance - zz$deviance
}
}
for (tt in scope) {
stt <- paste(sort(strsplit(tt, ":")[[1L]]), collapse = ":")
usex <- match(asgn, match(stt, sTerms), 0L) > 0L
X <- x[, usex | ousex, drop = FALSE]
z <- boostedglm:::fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[tt] <- z$rank
dev[tt] <- z$deviance
if (test == "Rao") {
zz <-  boostedglm:::fglm.wfit(r, X, , w, offset = offset)
score[tt] <- zz$null.deviance - zz$deviance
}
}
oTerms <- attr(object$terms, "term.labels")
int <- attr(object$terms, "intercept")
ns <- length(scope)
dfs <- dev <- score <- numeric(ns + 1)
names(dfs) <- names(dev) <- names(score) <- c("<none>", scope)
add.rhs <- paste(scope, collapse = "+")
add.rhs <- eval(parse(text = paste("~ . +", add.rhs), keep.source = FALSE))
new.form <- update.formula(object, add.rhs)
Terms <- terms(new.form)
y <- object$y
if (is.null(x)) {
fc <- object$call
fc$formula <- Terms
fob <- list(call = fc, terms = Terms)
class(fob) <- oldClass(object)
m <- model.frame(fob)
offset <- model.offset(m)
wt <- weights
x <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
oldn <- length(y)
y <- model.response(m)
if (!is.factor(y)) {
storage.mode(y) <- "double"
}
if (NCOL(y) == 2) {
n <- y[, 1] + y[, 2]
y <- ifelse(n == 0, 0, y[, 1] / n)
if (is.null(wt)) {
wt <- rep.int(1, length(y))
}
wt <- wt * n
}
newn <- length(y)
if (newn < oldn) {
warning(sprintf(
ngettext(
newn, "using the %d/%d row from a combined fit",
"using the %d/%d rows from a combined fit"
),
newn, oldn
), domain = NA)
}
} else {
wt <- object$prior.weights
offset <- object$offset
}
n <- nrow(x)
if (is.null(wt)) {
wt <- rep.int(1, n)
}
Terms <- attr(Terms, "term.labels")
asgn <- attr(x, "assign")
ousex <- match(asgn, match(oTerms, Terms), 0L) > 0L
if (int) {
ousex[1L] <- TRUE
}
X <- x[, ousex, drop = FALSE]
z <-  boostedglm:::fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[1L] <- z$rank
dev[1L] <- z$deviance
r <- z$residuals
w <- z$weights
sTerms <- sapply(strsplit(Terms, ":", fixed = TRUE), function(x) {
paste(sort(x),
collapse = ":"
)
})
for (tt in scope) {
stt <- paste(sort(strsplit(tt, ":")[[1L]]), collapse = ":")
usex <- match(asgn, match(stt, sTerms), 0L) > 0L
X <- x[, usex | ousex, drop = FALSE]
z <- boostedglm:::fglm.wfit(y, X, , wt, offset = offset, family = object$family)
dfs[tt] <- z$rank
dev[tt] <- z$deviance
if (test == "Rao") {
zz <-  boostedglm:::fglm.wfit(r, X, , w, offset = offset)
score[tt] <- zz$null.deviance - zz$deviance
}
}
summary(object, dispersion = NULL)$dispersion
foo = summary(object, dispersion = NULL)
foo$dispersion
scale
z <- object
var_res <- as.numeric(z$RSS / z$df.residual)
dispersion <- if (z$family$family %in% c("poisson", "binomial")) 1 else var_res
if (z$singularity.method == "qr") {
z$XTX <- z$XTX[z$ok, z$ok]
}
inv <- solve(z$XTX, tol = z$tol.solve)
covmat <- diag(inv)
se_coef <- rep(NA, length(z$coefficients))
se_coef[z$ok] <- sqrt(dispersion * covmat)
if (z$family$family %in% c("binomial", "poisson")) {
z1 <- z$coefficients / se_coef
p <- 2 * pnorm(abs(z1), lower.tail = FALSE)
} else {
t1 <- z$coefficients / se_coef
p <- 2 * pt(abs(t1), df = z$df.residual, lower.tail = FALSE)
}
ip <- !is.na(p)
p[ip] <- as.numeric(format(p[ip], digits = 3))
dn <- c("Estimate", "Std. Error")
if (z$family$family %in% c("binomial", "poisson")) {
format.coef <- if (any(na.omit(abs(z$coef)) < 1e-04)) {
format(z$coefficients, scientific = TRUE, digits = 4)
} else {
round(z$coefficients, digits = 7)
}
format.se <- if (any(na.omit(se_coef) < 1e-04)) {
format(se_coef, scientific = TRUE, digits = 4)
} else {
round(se_coef, digits = 7)
}
format.pv <- if (any(na.omit(p) < 1e-04)) {
format(p, scientific = TRUE, digits = 4)
} else {
round(p, digits = 4)
}
param <- data.frame(format.coef, format.se, round(z1,
digits = 4
), format.pv)
dimnames(param) <- list(names(z$coefficients), c(
dn,
"z value", "Pr(>|z|)"
))
} else {
format.coef <- if (any(abs(na.omit(z$coefficients)) <
1e-04)) {
format(z$coefficients, scientific = TRUE, digits = 4)
} else {
round(z$coefficients, digits = 7)
}
format.se <- if (any(na.omit(se_coef) < 1e-04)) {
format(se_coef, scientific = TRUE, digits = 4)
} else {
round(se_coef, digits = 7)
}
format.pv <- if (any(na.omit(p) < 1e-04)) {
format(p, scientific = TRUE, digits = 4)
} else {
round(p, digits = 4)
}
param <- data.frame(format.coef, format.se, round(t1,
digits = 4
), format.pv)
dimnames(param) <- list(names(z$coefficients), c(
dn,
"t value", "Pr(>|t|)"
))
}
eps <- 10 * .Machine$double.eps
if (z$family$family == "binomial") {
if (any(z$mu > 1 - eps) || any(z$mu < eps)) {
warning("fitted probabilities numerically 0 or 1 occurred")
}
}
if (z$family$family == "poisson") {
if (any(z$mu < eps)) {
warning("fitted rates numerically 0 occurred")
}
}
deviance.resid <- stats::residuals(z, type = "deviance")
deviance.resid <- residuals(z, type = "deviance")
boostedglm:::residuals.fglm(z)
object = z
y <- object$y
r <- object$residuals
mu <- object$fitted.values
wts <- object$prior.weights
switch(type, deviance = , pearson = , response = if (is.null(y)) {
mu.eta <- object$family$mu.eta
eta <- object$linear.predictors
y <- mu + r * mu.eta(eta)
})
type = "deviance"
switch(type, deviance = , pearson = , response = if (is.null(y)) {
mu.eta <- object$family$mu.eta
eta <- object$linear.predictors
y <- mu + r * mu.eta(eta)
})
res <- switch(
type,
deviance = if (object$df.residual > 0) {
d.res <- sqrt(pmax((object$family$dev.resids)(y, mu,
wts), 0))
ifelse(y > mu, d.res, -d.res)
} else {
rep.int(0, length(mu))
},
pearson = (y - mu) * sqrt(wts) / sqrt(object$family$variance(mu)),
working = r, response = y - mu, partial = r
)
y - mu
object$df.residual
object$family$dev.resids
object$family$dev.resids()
object$family$dev.resids
wts
mu
d.res <- sqrt(pmax((object$family$dev.resids)(y, mu, wts), 0))
sqrt(pmax((object$family$dev.resids)(y, mu, wts), 0))
(object$family$dev.resids)(y, mu, wts)
y
mu
wts
length(mu)
pmax((object$family$dev.resids)(y, mu, wts)
pmax((object$family$dev.resids)(y, mu, wts))
y
mu
y
mu
y/mu
(object$family$dev.resids)(y, mu, wts)
object
foo = summary(m1, dispersion = NULL)
object = m1
y <- object$y
r <- object$residuals
mu <- object$fitted.values
wts <- object$prior.weights
(object$family$dev.resids)(y, mu, wts)
object = m2
y <- object$y
r <- object$residuals
mu <- object$fitted.values
wts <- object$prior.weights
(object$family$dev.resids)(y, mu, wts)
object = m1
y <- object$y
r <- object$residuals
mu <- object$fitted.values
wts <- object$prior.weights
y
object = m2
y2 <- object$y
r2 <- object$residuals
mu2 <- object$fitted.values
wts2 <- object$prior.weights
y
y2
all.equal(y,y2)
all.equal(r,r2)
all.equal(mu,mu2)
mu
mu2
m2$linear.predictors
m2$linear.predictors
m2$fitted.values
m1$fitted.values
m1$linear.predictors
fitted(m2)
m2$linear.predictors
library(boostedglm)
devtools::test()
library(boostedglm)
devtools::test()
library(boostedglm)
devtools::test()
library(boostedglm)
devtools::test()
library(boostedglm)
library(boostedglm)
devtools::test()
devtools::check()
library(boostedglm)
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- fglm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2$qr
names(m1)
names(m2)[!names(m2) %in% names(m1)]
m2$link
names(m2)[!names(m2) %in% names(m1)]
m2$dispersion
library(boostedglm)
devtools::test()
library(boostedglm)
devtools::test()
devtools::test()
library(boostedglm)
