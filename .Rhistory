# eglm(trade ~ log_dist + cntg + lang + clny + exp_year + imp_year,      family = quasipoisson(link = "log"), data = ch1_application1_2,      y = FALSE, model = FALSE)
# min        lq      mean    median       uq        max neval
# 78.143386 82.797031 96.416335 85.072021 102.4835 147.671117    10
# 5.842121  5.967758  6.125419  6.039139   6.1037   6.857986    10
benchmark_times
benchmark_times$time
View(benchmark_times)
microbenchmark:::print.microbenchmark(benchmark_times)
writeLines(microbenchmark:::print.microbenchmark(benchmark_times), "dev/benchmarktimes.txt")
aaa = microbenchmark:::print.microbenchmark(benchmark_times)
aaa
View(aaa)
benchmark_times_df <- microbenchmark:::print.microbenchmark(benchmark_times)
class(benchmark_times_df)
if (!require(readr)) install.packages("readr")
library(readr)
Sys.info()
Sys.Date()
Sys.time()
sprintf("dev/benchmarktimes_%s.csv"), Sys.time()
sprintf("dev/benchmarktimes_%s.csv", Sys.time())
droplets
sprintf("dev/benchmarktimes_%s.csv", droplet)
droplet <- "c2-2vcpu-4gb"
sprintf("dev/benchmarktimes_%s.csv", droplet)
write_csv(benchmark_times_df, sprintf("dev/benchmarktimes_%s.csv", droplet))
map(
seq_along(s$slug),
function(x) {
droplets[[x]] <- droplet(droplets[[x]]$id)
}
)
droplets
droplets
View(ch1_application1_2)
ch1_application1_2
ch1_application1_2 %>% select(trade, log_dist, cntg, lang, clny, exp_year, imp_year)
ch1_application1_2 %>% ungroup() %>% select(trade, log_dist, cntg, lang, clny, exp_year, imp_year)
ch1_application1_2 %>% ungroup() %>% select(trade, log_dist, cntg, lang, clny, exp_year, imp_year)
m1
m1 <- glm(trade ~ log_dist + cntg + lang + clny + exp_year + imp_year,
family = quasipoisson(link = "log"),
data = ch1_application1_2,
y = FALSE,
model = FALSE
)
aaa = model.frame(m1)
dim(aaa)
dim(m1$data)
yotover::yotov_clustered_glm(m1$formula, ch1_application1_2)
usethis::edit_r_environ()
usethis::edit_r_profile()
test_file("aaa")
test_file("99-broom-data_error")
library(eflm)
library(eflm)
eglm(mpg ~ log(wt))
eglm(mpg ~ log(wt), data = mtcars)
glm(mpg ~ log(wt), data = mtcars)
export_all()
devtools::load_all()
formula = "mpg ~ log(wt)"
data = mtcars
family = gaussian()
formula = "mpg ~ log(wt)"
data = mtcars
family = gaussian()
intercept = TRUE
weights = NULL
na.action = na.omit
start = NULL
etastart = NULL,
etastart = NULL
mustart = NULL
offset = NULL
maxit = 25
k = 2
formula = "mpg ~ log(wt)"
data = mtcars
family = gaussian()
intercept = TRUE
weights = NULL
na.action = na.omit
start = NULL
etastart = NULL
mustart = NULL
offset = NULL
maxit = 25
k = 2
model = TRUE
singularity.method = c("eigen", "Cholesky", "qr")
x = FALSE
y = TRUE
tol.estimation = 1e-8
tol.solve = .Machine$double.eps
tol.values = 1e-7
tol.vectors = 1e-7
formula = "mpg ~ log(wt)"
data = mtcars
family = gaussian()
intercept = TRUE
weights = NULL
na.action = na.omit
start = NULL
etastart = NULL
mustart = NULL
offset = NULL
maxit = 25
k = 2
model = TRUE
singularity.method = c("eigen", "Cholesky", "qr")
x = FALSE
y = TRUE
tol.estimation = 1e-8
tol.solve = .Machine$double.eps
tol.values = 1e-7
tol.vectors = 1e-7
devtools::load_all()
library(eflm)
formula = "mpg ~ log(wt)"
data = mtcars
family = gaussian()
intercept = TRUE
weights = NULL
na.action = na.omit
start = NULL
etastart = NULL
mustart = NULL
offset = NULL
maxit = 25
k = 2
model = TRUE
singularity.method = c("eigen", "Cholesky", "qr")
x = FALSE
y = TRUE
tol.estimation = 1e-8
tol.solve = .Machine$double.eps
tol.values = 1e-7
tol.vectors = 1e-7
call <- match.call()
target <- y
M <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data"), names(M), 0L)
M <- M[c(1L, m)]
M$drop.unused.levels <- TRUE
M[[1L]] <- quote(stats::model.frame)
M <- eval(M, parent.frame())
call <- match.call()
target <- y
M <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data"), names(M), 0L)
M <- M[c(1L, m)]
M$drop.unused.levels <- TRUE
M[[1L]] <- quote(stats::model.frame)
M <- eval(M, parent.frame())
call <- match.call()
target <- y
M <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data"), names(M), 0L)
M <- M[c(1L, m)]
M$drop.unused.levels <- TRUE
M[[1L]] <- quote(stats::model.frame)
M <- eval(M)
y <- M[[1]]
call <- match.call()
target <- y
M <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data"), names(M), 0L)
M <- M[c(1L, m)]
M$drop.unused.levels <- TRUE
M[[1L]] <- quote(stats::model.frame)
M <- eval(M, parent.frame())
y <- M[[1]]
tf <- attr(M, "terms")
X <- model.matrix(tf, M)
offset <- model.offset(M)
intercept <- attributes(tf)$intercept
singularity.method <- match.arg(singularity.method)
rval <- eglm.wfit(
X = X,
y = y,
family = family,
weights = weights,
start = start,
etastart = etastart,
mustart = mustart,
offset = offset,
intercept = intercept,
maxit = maxit,
k = k,
tol.estimation = tol.estimation,
tol.solve = tol.solve,
tol.values = tol.values,
tol.vectors = tol.vectors,
singularity.method = singularity.method
)
source('~/github/eflm/R/eglm-wfit.R')
rval <- eglm.wfit(
X = X,
y = y,
family = family,
weights = weights,
start = start,
etastart = etastart,
mustart = mustart,
offset = offset,
intercept = intercept,
maxit = maxit,
k = k,
tol.estimation = tol.estimation,
tol.solve = tol.solve,
tol.values = tol.values,
tol.vectors = tol.vectors,
singularity.method = singularity.method
)
source('~/github/eflm/R/eglm.R')
source('~/github/eflm/dev/testing-parameters.R')
eglm(mpg ~ wt, mtcars)
source('~/github/eflm/R/eglm.R')
target <- y
M
source('~/github/eflm/R/eglm.R')
M <- eglm(mpg ~ log(wt), mtcars)
source('~/github/eflm/R/eglm.R')
y <- M[[1]]
y
tf <- attr(M, "terms")
X <- model.matrix(tf, M)
X
offset <- model.offset(M)
rval <- eglm.wfit(
X = X,
y = y,
family = family,
weights = weights,
start = start,
etastart = etastart,
mustart = mustart,
offset = offset,
intercept = intercept,
maxit = maxit,
k = k,
tol.estimation = tol.estimation,
tol.solve = tol.solve,
tol.values = tol.values,
tol.vectors = tol.vectors,
singularity.method = singularity.method
)
X <- model.matrix(tf, M)
library(eflm)
eglm(mpg ~ log(wt), mtcars)
aa = glm(mpg ~ log(wt), mtcars)
aa = glm(mpg ~ log(wt), mtcars, family = gaussian())
aa
aa
aa$control
aa$fitted.values
aa = glm(mpg ~ log(wt), mtcars, family = gaussian())
eglm(mpg ~ log(wt), mtcars, family = gaussian())
library(eflm)
eglm(mpg ~ log(wt), mtcars, family = gaussian())
glm(mpg ~ log(wt), mtcars, family = gaussian())
eglm(mpg ~ log(wt), mtcars, family = gaussian())
glm(mpg ~ log(wt), mtcars, family = gaussian())
eglm(mpg ~ log(wt), mtcars, family = gaussian())
lm(mpg ~ log(wt), mtcars)
elm(mpg ~ log(wt), mtcars)
library(eflm)
lm(mpg ~ log(wt), mtcars)
elm(mpg ~ log(wt), mtcars)
usethis::use_apache_license()
use_news_md()
rep.int(0,10)
rep(0,10.1)
W = 1:3
res = 3:5
all.equal(W * res * res, W * (res^2))
use_r("utils")
styler::style_file("R/helpers.R"
)
library(eflm)
test()
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars)
test_that("eglm (gaussian) == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$qr$qr, m2$qr$qr)
expect_equal(m1$qr$rank, m2$qr$rank)
expect_equal(m1$qr$qraux, m2$qr$qraux)
expect_equal(m1$qr$pivot, m2$qr$pivot)
expect_equal(m1$qr$tol, m2$qr$tol)
})
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$qr$qr, m2$qr$qr)
expect_equal(m1$qr$rank, m2$qr$rank)
expect_equal(m1$qr$qraux, m2$qr$qraux)
expect_equal(m1$qr$pivot, m2$qr$pivot)
expect_equal(m1$qr$tol, m2$qr$tol)
expect_equal(m1$qr$qr, m2$qr$qr)
expect_equal(m1$call$data, m2$call$data)
m1$qr$qr
m2$qr$qr
m2$qr
m2$qr$qr
expect_equal(m1$qr$rank, m2$qr$rank)
expect_equal(m1$qr$qraux, m2$qr$qraux)
expect_equal(m1$qr$pivot, m2$qr$pivot)
expect_equal(m1$qr$tol, m2$qr$tol)
expect_equal(m1$qr$qr, m2$qr$qr)
m1$qr$qraux
m2$qr$qraux
m1$qr$pivot
m2$qr$pivot
expect_equal(m1$qr$qr, m2$qr$qr)
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars, singularity.method = "qr")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
test_that("eglm (gaussian) + qr singularity.method == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars, singularity.method = "qr")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
})
test_that("eglm (gaussian) + cholesky singularity.method == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian(), data = mtcars, singularity.method = "Cholesky")
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$family$family, m2$family$family)
expect_equal(m1$family$link, m2$family$link)
expect_equal(m1$linear.predictors, m2$linear.predictors)
expect_equal(m1$deviance, m2$deviance)
expect_equal(m1$aic, m2$aic)
expect_equal(m1$null.deviance, m2$null.deviance)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$df.null, m2$df.null)
expect_equal(m1$y, m2$y)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$family, m2$call$family)
expect_equal(m1$call$data, m2$call$data)
expect_equal(
predict(m1, newdata = mtcars, type = "link"),
predict(m2, newdata = mtcars, type = "link")
)
expect_equal(
predict(m1, newdata = mtcars, type = "response"),
predict(m2, newdata = mtcars, type = "response")
)
})
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
expect_equal(fitted(m1), fitted(m2))
expect_equal(coef(m1), coef(m2))
expect_equal(vcov(m1), vcov(m2))
expect_equal(deviance(m1), deviance(m2))
expect_equal(nobs(m1), nobs(m2))
expect_equal(model.matrix(m1), model.matrix(m2))
class(m1)
class(m2)
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
m2
m1
class(m2)
class(m2) = "eglm"
nobs(m2)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
m1 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
nobs(m1)
class(m1)
library(eflm)
library(eflm)
m1 <- glm(mpg ~ wt, family = gaussian(), data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian(), data = mtcars)
family(m1)
family(m2)
expect_equal(family(m1), family(m2))
fm1 <- family(m1)
fm2 <- family(m2)
expect_equal(fm1$family, fm2$family)
expect_equal(fm1$link, fm2$link)
fm1$linkfun()
fm1$linkfun
fm1$aic
fm1$aic()
library(eflm)
test()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
check()
test()
library(eflm)
test()
check()
library(eflm)
library(eflm)
test()
m1 <- lm(mpg ~ wt + am, data = mtcars)
m2 <- elm(mpg ~ wt + am, data = mtcars)
resid(m1)
residuals(m1)
residuals(m2)
residuals(m2)
library(eflm)
test(0)
test()
check()
library(eflm)
test()
check()
library(eflm)
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
m1 <- eglm(mpg ~ I(wt^2), mtcars)
class(m1)
library(eflm)
m1 <- eglm(mpg ~ I(wt^2), mtcars)
class(m1)
check()
