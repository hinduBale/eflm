library(eflm)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
bm1 <- broom::tidy(m1)
bm2 <- broom::tidy(m2)
bm3 <- broom::tidy(m3)
expect_equal(bm1$term, bm2$term)
expect_equal(bm1$estimate, bm2$estimate)
expect_equal(bm1$estimate, bm3$estimate)
expect_equal(round(bm1$std.error, 4), round(bm2$std.error, 4))
expect_equal(round(bm1$statistic, 4), round(bm2$statistic, 4))
expect_equal(round(bm1$std.error, 4), round(bm3$std.error, 4))
expect_equal(round(bm1$statistic, 4), round(bm3$statistic, 4))
expect_equal(bm1$p.value, bm2$p.value)
expect_equal(bm1$p.value, bm3$p.value)
bm1 <- broom::tidy(m1, conf.int = TRUE)
bm2 <- broom::tidy(m2, conf.int = TRUE)
bm3 <- broom::tidy(m3, conf.int = TRUE)
bm1 <- broom::tidy(m1, conf.int = TRUE)
bm2 <- broom::tidy(m2, conf.int = TRUE)
bm3 <- broom::tidy(m3, conf.int = TRUE)
expect_equal(bm1$conf.low, bm2$conf.low)
expect_equal(bm1$conf.high, bm2$conf.high)
expect_equal(bm1$conf.low, bm3$conf.low)
expect_equal(bm1$conf.high, bm3$conf.high)
library(eflm)
check()
library(purrr)
use_package("purrr", "suggests")
library(purrr)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
use_r("99-broom-response")
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
check()
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
library(eflm)
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
library(eflm)
check()
use_r("99-broom-augment-elm")
library(eflm)
check()
library(eflm)
library(eflm)
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
check()
library(eflm)
use_r("99-broom-tidy-elm")
library(eflm)
check()
test_that("broom outputs not explicitly defined are the same as glm", {
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
expect_equal(broom::augment(m1, newdata = mtcars), broom::augment(m2, newdata = mtcars))
expect_equal(broom::augment(m1, newdata = mtcars), broom::augment(m3, newdata = mtcars))
})
expect_equal(bm2$conf.low, bm1$conf.low)
expect_equal(bm3$conf.high, bm1$conf.high)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
bm1 <- broom::tidy(m1)
bm2 <- broom::tidy(m2)
bm3 <- broom::tidy(m3)
expect_equal(bm2$term, bm1$term)
expect_equal(bm2$estimate, bm1$estimate)
expect_equal(bm3$term, bm1$term)
expect_equal(bm3$estimate, bm1$estimate)
expect_equal(round(bm2$std.error, 4), round(bm1$std.error, 4))
expect_equal(round(bm2$statistic, 4), round(bm1$statistic, 4))
expect_equal(round(bm3$std.error, 4), round(bm1$std.error, 4))
expect_equal(round(bm3$statistic, 4), round(bm1$statistic, 4))
expect_equal(bm2$p.value, bm1$p.value)
expect_equal(bm3$p.value, bm1$p.value)
bm1 <- broom::tidy(m1, conf.int = TRUE)
bm2 <- broom::tidy(m2, conf.int = TRUE)
expect_equal(bm2$conf.low, bm1$conf.low)
expect_equal(bm3$conf.high, bm1$conf.high)
expect_equal(bm2$conf.high, bm1$conf.high)
expect_equal(bm2$conf.high, bm1$conf.high)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
bm1 <- broom::tidy(m1)
bm2 <- broom::tidy(m2)
bm3 <- broom::tidy(m3)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
x = m3
bm3 <- broom::tidy(m3, conf.int = TRUE)
conf.int = TRUE
conf.level = 0.95
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
ret
x = m2
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
ret
x = m3
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
ret
bm3 <- broom::tidy(m3, conf.int = TRUE)
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
ret
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
coefs
x = m2
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
coefs
x = m3
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
coefs
ret <- merge(coefs, ret, by = c("term", "estimate"))
ret
x = m2
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
ret <- merge(coefs, ret, by = c("term", "estimate"))
ret
x = m3
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
ret <- merge(coefs, ret, by = c("term", "estimate"))
ret
conf.int
ci <- confint_terms(x, level = conf.level)
ci
x = m2
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
ret <- merge(coefs, ret, by = c("term", "estimate"))
ci <- confint_terms(x, level = conf.level)
ci
x = m3
ret <- tibble::as_tibble(summary(x)$coefficients, rownames = "term")
colnames(ret) <- c("term", "estimate", "std.error", "statistic", "p.value")
coefs <- tibble::enframe(stats::coef(x), name = "term", value = "estimate")
ret <- merge(coefs, ret, by = c("term", "estimate"))
ci <- confint_terms(x, level = conf.level)
ci
confint(x)
confint(m2)
use_r("elm-confint")
object = m2
level = 0.95
object = m2
cf <- coef(object)
ses <- sqrt(diag(vcov(object))) # gives NA for aliased parms
ses
cf
obvject = m3
object = m3
cf <- coef(object)
ses <- sqrt(diag(vcov(object))) # gives NA for aliased parms
cf
ses
use_r("elm-vcov")
library(eflm)
object = m2
cf <- coef(object)
ses <- sqrt(diag(vcov(object))) # gives NA for aliased parms
ses
object = m3
cf <- coef(object)
ses <- sqrt(diag(vcov(object))) # gives NA for aliased parms
ses
use_r("elm-vcov-summary")
library(eflm)
m1 <- summary(lm(mpg ~ wt, data = mtcars))
m2 <- summary(elm(mpg ~ wt, data = mtcars, reduce = T))
m3 <- summary(elm(mpg ~ wt, data = mtcars, reduce = F))
m1 <- lm(mpg ~ wt + am, data = mtcars)
m2 <- elm(mpg ~ wt + am, data = mtcars, reduce = T)
m3 <- elm(mpg ~ wt + am, data = mtcars, reduce = F)
object = m2
library(eflm)
load_all()
vcov.elm(m2)
vcov.elm(m3)
vcov.elm(m3) == vcov.elm(2)
vcov.elm(m3) == vcov.elm(m2)
use_test("elm-vcov")
m1 <- lm(mpg ~ wt + am, data = mtcars)
m2 <- elm(mpg ~ wt + am, data = mtcars, reduce = T)
m3 <- elm(mpg ~ wt + am, data = mtcars, reduce = F)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$effects, m2$effects)
m1$effects
m2$effects
use_r("format.perc")
library(eflm)
eglm(am ~ ., family = binomial, data = mtcars)
library(eflm)
expect_
eglm(am ~ ., family = binomial, data = mtcars)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, drop = F)
library(eflm)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
expect_equal(fitted(m2), fitted(m1))
expect_equal(coef(m2), coef(m1))
expect_equal(vcov(m2), vcov(m1))
expect_equal(deviance(m2), deviance(m1))
expect_equal(nobs(m2), nobs(m1))
expect_equal(model.matrix(m2), model.matrix(m1))
expect_equal(fitted(m3), fitted(m1))
expect_equal(coef(m3), coef(m1))
expect_equal(vcov(m3), vcov(m1))
expect_equal(deviance(m3), deviance(m1))
expect_equal(nobs(m3), nobs(m1))
expect_equal(model.matrix(m3), model.matrix(m1))
expect_equal(fitted(m3), fitted(m1))
expect_equal(coef(m3), coef(m1))
expect_equal(vcov(m3), vcov(m1))
expect_equal(deviance(m3), deviance(m1))
expect_equal(nobs(m3), nobs(m1))
expect_equal(model.matrix(m3), model.matrix(m1))
vcov(m3)
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt, data = mtcars, reduce = T)
object = m2
object$aliased
object$sigma^2
object$cov.unscaled
.vcov.aliased(object$aliased, object$sigma^2 * object$cov.unscaled, complete=complete)
complete = TRUE
.vcov.aliased(object$aliased, object$sigma^2 * object$cov.unscaled, complete=complete)
vcov.summary.elm(summary.elm(object, ...), complete=complete)
load_all()
vcov.elm(m21)
vcov.elm(m2)
vcov.elm(m3)
library(eflm)
m1 <- lm(mpg ~ wt + am, data = mtcars)
m2 <- elm(mpg ~ wt + am, data = mtcars, reduce = F)
m3 <- elm(mpg ~ wt + am, data = mtcars, reduce = T)
expect_equal(m1$coefficients, m2$coefficients)
expect_equal(m1$residuals, m2$residuals)
expect_equal(m1$rank, m2$rank)
expect_equal(m1$fitted.values, m2$fitted.values)
expect_equal(m1$assign, m2$assign)
expect_equal(m1$effects, m2$effects)
expect_equal(m1$qr$qr, m2$qr$qr)
expect_equal(m1$qr$qraux, m2$qr$qraux)
expect_equal(m1$qr$pivot, m2$qr$pivot)
expect_equal(m1$qr$tol, m2$qr$tol)
expect_equal(m1$qr$rank, m2$qr$rank)
expect_equal(m1$df.residual, m2$df.residual)
expect_equal(m1$xlevels, m2$xlevels)
expect_equal(m1$call$formula, m2$call$formula)
expect_equal(m1$call$data, m2$call$data)
expect_equal(m1$terms, m2$terms)
expect_equal(m1$model, m2$model)
expect_equal(m1$coefficients, m3$coefficients)
expect_equal(m1$residuals, m3$residuals)
expect_equal(m1$rank, m3$rank)
expect_equal(m1$fitted.values, m3$fitted.values)
expect_equal(m1$assign, m3$assign)
# the QR decomposition is different by definition
expect_equal(m1$effects, m3$effects)
# the QR decomposition is different by definition
# expect_equal(m1$effects, m3$effects)
expect_equal(m1$qr$qr, m3$qr$qr)
# the QR decomposition is different by definition
# expect_equal(m1$effects, m3$effects)
# expect_equal(m1$qr$qr, m3$qr$qr)
expect_equal(m1$qr$qraux, m3$qr$qraux)
# the QR decomposition is different by definition
# expect_equal(m1$effects, m3$effects)
# expect_equal(m1$qr$qr, m3$qr$qr)
# expect_equal(m1$qr$qraux, m3$qr$qraux)
expect_equal(m1$qr$pivot, m3$qr$pivot)
test_that("eglm (gaussian) == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (gaussian) == glm", {
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (inverse.gaussian) == glm", {
m1 <- glm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (gaussian) == glm", {
m1 <- glm(mpg ~ wt + am, family = Gamma, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = Gamma, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = Gamma, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (binomial) == glm", {
m1 <- glm(am ~ wt + mpg, family = binomial, data = mtcars)
m2 <- eglm(am ~ wt + mpg, family = binomial, data = mtcars, reduce = F)
m3 <- eglm(am ~ wt + mpg, family = binomial, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (quasibinomial) == glm", {
m1 <- glm(am ~ wt + mpg, family = quasibinomial, data = mtcars)
m2 <- eglm(am ~ wt + mpg, family = quasibinomial, data = mtcars, reduce = F)
m3 <- eglm(am ~ wt + mpg, family = quasibinomial, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (quasipoisson) == glm", {
m1 <- glm(mpg ~ wt + am, family = quasipoisson, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = quasipoisson, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = quasipoisson, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
test_that("eglm (quasi) == glm", {
m1 <- glm(mpg ~ wt + am, family = quasi, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = quasi, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = quasi, data = mtcars, reduce = T)
expect_equal(
predict(m2, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m2, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
expect_equal(
predict(m3, newdata = mtcars, type = "link"),
predict(m1, newdata = mtcars, type = "link")
)
expect_equal(
predict(m3, newdata = mtcars, type = "response"),
predict(m1, newdata = mtcars, type = "response")
)
})
library(eflm)
class(eglm(mpg~wt), data = mtcars)
class(eglm(mpg~wt, data = mtcars))
class(elm(mpg~wt, data = mtcars))
library(eflm)
use_test("elm-predict")
use_test("eglm-formulas")
use_test("elm-sandwich")
m1 <- lm(mpg ~ wt, data = mtcars)
m2 <- elm(mpg ~ wt, data = mtcars, reduce = F)
vcov_m1 <- sandwich::vcovCL(m1, cluster = NULL)
vcov_m2 <- sandwich::vcovCL(m2, cluster = NULL)
expect_equal(vcov_m2, vcov_m1)
