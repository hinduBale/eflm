expect_gte(m3$iter, m1$iter)
expect_equal(m3$deviance.resid, m1$deviance.resid)
expect_equal(m3$dispersion, m1$dispersion)
expect_equal(m3$cov.unscaled, m1$cov.unscaled)
# expect_equal(m3$cov.scaled, m1$cov.scaled)
expect_equal(em1$Estimate, em3$Estimate)
# expect_equal(em1$`Std. Error`, em3$`Std. Error`)
# expect_equal(em1$`t value`, em3$`t value`)
# expect_equal(em1$`Pr(>|t|)`, em3$`Pr(>|t|)`)
})
object = m2
Qr <- qr.elm(object)
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
chol2inv(object$xtx)
object = m3
chol2inv(object$xtx)
x = cbind(matrix(rep(1,length(mtcars$wt)), ncol = 1), mtcars$wt)
dim(x)
class(x)
y = matrix(mtcars$mpg, ncol = 1)
weights = rep(1,length(mtcars$mpg))
lm1 <- elm.wfit(x, y, weights, reduce = F)
lm2 <- elm.wfit(x, y, weights, reduce = T)
glm1 <- eglm.wfit(x, y, weights, reduce = F)
glm2 <- eglm.wfit(x, y, weights, reduce = T)
glm12 <- eglm(mpg ~ wt, data = mtcars, reduce = F, x = T)
glm22 <- eglm(mpg ~ wt, data = mtcars, reduce = T, x = T)
class(glm12)
class(glm22)
class(glm1)
m1 <- glm(mpg ~ wt + am, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = gaussian, data = mtcars, reduce = T)
object = m2
Qr <- qr.elm(object)
chol2inv(Qr$qr[p1, p1, drop = FALSE])
p1 <- 1L:p
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
## WATCHIT! doesn't this rely on pivoting not permuting 1L:p? -- that's quaranteed
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
object = m3
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
object$reduce
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
## WATCHIT! doesn't this rely on pivoting not permuting 1L:p? -- that's quaranteed
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
object = m3
solve(object$xtx)
m1 <- glm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = T)
object = m2
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
## WATCHIT! doesn't this rely on pivoting not permuting 1L:p? -- that's quaranteed
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
object$reduce
chol2inv(Qr$qr[p1, p1, drop = FALSE])
object = m3
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
## WATCHIT! doesn't this rely on pivoting not permuting 1L:p? -- that's quaranteed
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
solve(object$xtx)
m1 <- glm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = T)
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
object = m3
p1 <- 1L:p
Qr <- qr.elm(object)
## WATCHIT! doesn't this rely on pivoting not permuting 1L:p? -- that's quaranteed
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
qr(m2$qr)
summary(m1)$cov.unscaled
solve(object$xtx)
object$xtx %*% object$xtx
1 / object$xtx
solve(1 / object$xtx)
family(m1)
family(m2)
1 / (object$xtx)^2
1 / solve(object$xtx)^2
1 / solve(object$xtx)
1 / (object$xtx %*% object$xtx)
1 / (object$xtx * object$xtx)
unname(solve.qr(qr(object$xtx, LAPACK = T)))
1 / unname(solve.qr(qr(object$xtx, LAPACK = T)))^2
1 / (unname(solve.qr(qr(object$xtx, LAPACK = T))) * unname(solve.qr(qr(object$xtx, LAPACK = T))))
stats:::make.link("inverse.gaussian")
stats:::make.link(inverse.gaussian)
stats:::make.link(m1)
library(eflm)
m1 <- glm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = T)
object = m2
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
dispersion = NULL
correlation = FALSE
symbolic.cor = FALSE
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
load_all()
p1 <- 1L:p
Qr <- qr.elm(object)
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
object = m3
est.disp <- FALSE
df.r <- object$df.residual
if (is.null(dispersion)) { # calculate dispersion if needed
dispersion <-
if (object$family$family %in% c("poisson", "binomial")) {
1
} else if (df.r > 0) {
est.disp <- TRUE
if (any(object$weights == 0)) {
warning("observations with zero weight not used for calculating dispersion")
}
sum((object$weights * object$residuals^2)[object$weights > 0]) / df.r
} else {
est.disp <- TRUE
NaN
}
}
## calculate scaled and unscaled covariance matrix
aliased <- is.na(coef(object)) # used in print method
p <- object$rank
p1 <- 1L:p
Qr <- qr.elm(object)
## WATCHIT! doesn't this rely on pivoting not permuting 1L:p? -- that's quaranteed
coef.p <- object$coefficients[Qr$pivot[p1]]
covmat.unscaled <- if (isTRUE(object$reduce)) {
unname(solve.qr(qr(object$xtx, LAPACK = T)))
} else {
chol2inv(Qr$qr[p1, p1, drop = FALSE])
}
covmat.unscaled
m1 <- glm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = T)
library(eflm)
m1 <- glm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt + am, family = inverse.gaussian, data = mtcars, reduce = T)
m2$reduce
m3$xtx
m3$family$linkinv()
m3$family$linkinv()
m3$family$linkinv(eta = 0)
m3$family$linkinv(unname(solve.qr(qr(object$xtx, LAPACK = T))))
test()
test_that("gaussian summary is equivalent to glm", {
m1 <- summary(glm(mpg ~ wt, family = gaussian, data = mtcars))
m2 <- summary(eglm(mpg ~ wt, family = gaussian, data = mtcars, reduce = F))
m3 <- summary(eglm(mpg ~ wt, family = gaussian, data = mtcars, reduce = T))
em1 <- as.data.frame(m1$coefficients)
em2 <- as.data.frame(m2$coefficients)
em3 <- as.data.frame(m3$coefficients)
expect_equal(m2$call$formula, m1$call$formula)
expect_equal(m2$call$family, m1$call$family)
expect_equal(m2$call$data, m1$call$data)
expect_equal(m2$terms, m1$terms)
expect_equal(m2$deviance, m1$deviance)
expect_equal(m2$aic, m1$aic)
expect_equal(m2$df.residual, m1$df.residual)
expect_equal(m2$df.null, m1$df.null)
expect_equal(m2$null.deviance, m1$null.deviance)
expect_gte(m2$iter, m1$iter)
expect_equal(m2$deviance.resid, m1$deviance.resid)
expect_equal(m2$dispersion, m1$dispersion)
expect_equal(m2$cov.unscaled, m1$cov.unscaled)
expect_equal(m2$cov.scaled, m1$cov.scaled)
expect_equal(em2$Estimate, em1$Estimate)
expect_equal(em2$`Std. Error`, em1$`Std. Error`)
expect_equal(em2$`t value`, em1$`t value`)
expect_equal(em2$`Pr(>|t|)`, em1$`Pr(>|t|)`)
expect_equal(m3$call$formula, m1$call$formula)
expect_equal(m3$call$family, m1$call$family)
expect_equal(m3$call$data, m1$call$data)
expect_equal(m3$terms, m1$terms)
expect_equal(m3$deviance, m1$deviance)
expect_equal(m3$aic, m1$aic)
expect_equal(m3$df.residual, m1$df.residual)
expect_equal(m3$df.null, m1$df.null)
expect_equal(m3$null.deviance, m1$null.deviance)
expect_gte(m3$iter, m1$iter)
expect_equal(m3$deviance.resid, m1$deviance.resid)
expect_equal(m3$dispersion, m1$dispersion)
expect_equal(m3$cov.unscaled, m1$cov.unscaled)
expect_equal(m3$cov.scaled, m1$cov.scaled)
expect_equal(em3$Estimate, em1$Estimate)
expect_equal(em3$`Std. Error`, em1$`Std. Error`)
expect_equal(em3$`t value`, em1$`t value`)
expect_equal(em3$`Pr(>|t|)`, em1$`Pr(>|t|)`)
})
test_that("inverse.gaussian summary is equivalent to glm", {
m1 <- summary(glm(mpg ~ wt, family = inverse.gaussian, data = mtcars))
m2 <- summary(eglm(mpg ~ wt, family = inverse.gaussian, data = mtcars, reduce = F))
m3 <- summary(eglm(mpg ~ wt, family = inverse.gaussian, data = mtcars, reduce = T))
em1 <- as.data.frame(m1$coefficients)
em2 <- as.data.frame(m2$coefficients)
em3 <- as.data.frame(m3$coefficients)
expect_equal(m2$call$formula, m1$call$formula)
expect_equal(m2$call$family, m1$call$family)
expect_equal(m2$call$data, m1$call$data)
expect_equal(m2$terms, m1$terms)
expect_equal(m2$deviance, m1$deviance)
expect_equal(m2$aic, m1$aic)
expect_equal(m2$df.residual, m1$df.residual)
expect_equal(m2$df.null, m1$df.null)
expect_equal(m2$null.deviance, m1$null.deviance)
expect_gte(m2$iter, m1$iter)
expect_equal(m2$deviance.resid, m1$deviance.resid)
expect_equal(m2$dispersion, m1$dispersion)
expect_equal(m2$cov.unscaled, m1$cov.unscaled)
expect_equal(m2$cov.scaled, m1$cov.scaled)
expect_equal(em1$Estimate, em2$Estimate)
expect_equal(em1$`Std. Error`, em2$`Std. Error`)
expect_equal(em1$`t value`, em2$`t value`)
expect_equal(em1$`Pr(>|t|)`, em2$`Pr(>|t|)`)
expect_equal(m3$call$formula, m1$call$formula)
expect_equal(m3$call$family, m1$call$family)
expect_equal(m3$call$data, m1$call$data)
expect_equal(m3$terms, m1$terms)
expect_equal(m3$deviance, m1$deviance)
expect_equal(m3$aic, m1$aic)
expect_equal(m3$df.residual, m1$df.residual)
expect_equal(m3$df.null, m1$df.null)
expect_equal(m3$null.deviance, m1$null.deviance)
expect_gte(m3$iter, m1$iter)
expect_equal(m3$deviance.resid, m1$deviance.resid)
expect_equal(m3$dispersion, m1$dispersion)
# expect_equal(m3$cov.unscaled, m1$cov.unscaled)
# expect_equal(m3$cov.scaled, m1$cov.scaled)
expect_equal(em1$Estimate, em3$Estimate)
# expect_equal(em1$`Std. Error`, em3$`Std. Error`)
# expect_equal(em1$`t value`, em3$`t value`)
# expect_equal(em1$`Pr(>|t|)`, em3$`Pr(>|t|)`)
})
test_that("binomial summary is equivalent to glm", {
m1 <- summary(glm(am ~ mpg, family = binomial, data = mtcars))
m2 <- summary(eglm(am ~ mpg, family = binomial, data = mtcars, reduce = F))
m3 <- summary(eglm(am ~ mpg, family = binomial, data = mtcars, reduce = T))
em1 <- as.data.frame(m2$coefficients)
em2 <- as.data.frame(m2$coefficients)
em3 <- as.data.frame(m3$coefficients)
expect_equal(m2$call$formula, m1$call$formula)
expect_equal(m2$call$family, m1$call$family)
expect_equal(m2$call$data, m1$call$data)
expect_equal(m2$terms, m1$terms)
expect_equal(m2$deviance, m1$deviance)
expect_equal(m2$aic, m1$aic)
expect_equal(m2$df.residual, m1$df.residual)
expect_equal(m2$df.null, m1$df.null)
# expect_equal(m2$null.deviance, m1$null.deviance)
expect_gte(m2$iter, m1$iter)
expect_equal(m2$deviance.resid, m1$deviance.resid)
expect_equal(m2$dispersion, m1$dispersion)
expect_equal(m2$cov.unscaled, m1$cov.unscaled)
expect_equal(m2$cov.scaled, m1$cov.scaled)
expect_equal(em1$Estimate, em2$Estimate)
expect_equal(em1$`Std. Error`, em2$`Std. Error`)
expect_equal(em1$`z value`, em2$`z value`)
expect_equal(em1$`Pr(>|z|)`, em2$`Pr(>|z|)`)
expect_equal(m3$call$formula, m1$call$formula)
expect_equal(m3$call$family, m1$call$family)
expect_equal(m3$call$data, m1$call$data)
expect_equal(m3$terms, m1$terms)
expect_equal(m3$deviance, m1$deviance)
expect_equal(m3$aic, m1$aic)
expect_equal(m3$df.residual, m1$df.residual)
expect_equal(m3$df.null, m1$df.null)
expect_equal(m3$null.deviance, m1$null.deviance)
expect_gte(m3$iter, m1$iter)
expect_equal(m3$deviance.resid, m1$deviance.resid)
expect_equal(m3$dispersion, m1$dispersion)
# expect_equal(m3$cov.unscaled, m1$cov.unscaled)
# expect_equal(m3$cov.scaled, m1$cov.scaled)
expect_equal(em1$Estimate, em3$Estimate)
# expect_equal(em1$`Std. Error`, em3$`Std. Error`)
# expect_equal(em1$`z value`, em3$`z value`)
# expect_equal(em1$`Pr(>|z|)`, em3$`Pr(>|z|)`)
})
test()
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars, reduce = F)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars, reduce = T)
m1 <- glm(mpg ~ wt, family = gaussian, data = mtcars)
m2 <- eglm(mpg ~ wt, family = gaussian, data = mtcars, reduce = F)
m3 <- eglm(mpg ~ wt, family = gaussian, data = mtcars, reduce = T)
fm1 <- family(m1)
fm2 <- family(m2)
fm3 <- family(m3)
expect_equal(fm2$family, fm1$family)
expect_equal(fm2$link, fm1$link)
expect_equal(fitted(m2), fitted(m1))
expect_equal(coef(m2), coef(m1))
# expect_equal(vcov(m2), vcov(m1))
expect_equal(deviance(m2), deviance(m1))
expect_equal(nobs(m2), nobs(m1))
expect_equal(model.matrix(m2), model.matrix(m1))
expect_equal(fm3$family, fm1$family)
expect_equal(fm3$link, fm1$link)
expect_equal(fitted(m3), fitted(m1))
expect_equal(coef(m3), coef(m1))
# expect_equal(vcov(m3), vcov(m1))
expect_equal(deviance(m3), deviance(m1))
expect_equal(nobs(m3), nobs(m1))
expect_equal(model.matrix(m3), model.matrix(m1))
test()
